// Tool Service - Handles MCP tools, servers, and marketplace integrations
// Extracted from mcp.py functionality

import { TenantApiClient } from './TenantApiClient';
import { recordUsageAfterAction } from './BillingService';

export interface MCPTool {
  name: string;
  description: string;
  inputSchema?: {
    type: string;
    properties: Record<string, any>;
    required?: string[];
  };
  source: 'backend' | 'agent' | 'recorder' | 'marketplace';
  category?: string;
  metadata?: Record<string, any>;
}

export interface MCPServer {
  id: string;
  name: string;
  status: 'running' | 'stopped' | 'error' | 'installing';
  command?: string;
  args?: string[];
  tools: string[];
  disabledTools: string[];
  installedAt?: string;
  description?: string;
  version?: string;
  repository?: string;
  author?: string;
}

export interface RecorderTool {
  name: string;
  description: string;
  source: 'recorder' | 'agent-resources';
  sessionId?: string;
  filePath: string;
  filename: string;
  code?: string;
  metadata?: {
    sessionName?: string;
    recordingDate?: string;
    actionsCount?: number;
  };
}

export interface ToolExecutionResult {
  success: boolean;
  result?: any;
  error?: string;
  executionTime?: number;
  output?: string;
}

export interface MCPConfig {
  serverUrl: string;
  ideConfigs: {
    windsurf: any;
    cursor: string;
    cline: any;
    claudeCode: string;
  };
}

export class ToolService {
  private apiClient: TenantApiClient;
  private mcpServerUrl: string;

  constructor(tenantId: string) {
    this.apiClient = new TenantApiClient(tenantId);
    this.mcpServerUrl = `${this.apiClient.baseUrl}/mcp`;
  }

  /**
   * Get MCP server URL for external integration
   */
  getMCPServerUrl(): string {
    return this.mcpServerUrl;
  }

  /**
   * Generate MCP configuration for different IDEs
   */
  generateMCPConfig(ideType: string): any {
    const mcpUrl = this.getMCPServerUrl();
    
    switch (ideType) {
      case 'Windsurf':
        return {
          mcpServers: {
            mymcp: {
              command: 'curl',
              args: [mcpUrl]
            }
          }
        };
        
      case 'Cursor':
        return `Connect to: ${mcpUrl}`;
        
      case 'Cline/Roo Code':
        return {
          mcpServers: {
            mymcp: {
              url: mcpUrl
            }
          }
        };
        
      case 'Claude Code':
        return `claude mcp add MyMCP ${mcpUrl}`;
        
      default:
        return `Connect your IDE to: ${mcpUrl}`;
    }
  }

  /**
   * Get all available tools (backend + agent + recorder)
   */
  async getAllTools(): Promise<{
    backend: MCPTool[];
    agents: MCPTool[];
    recorded: RecorderTool[];
    marketplace: MCPTool[];
  }> {
    try {
      // Fetch backend and agent tools
      const toolsResponse = await this.apiClient.get('/tools');
      const allTools = toolsResponse.tools || [];
      
      // Separate agent tools from backend tools
      const agents = allTools.filter((tool: MCPTool) => 
        tool.name.startsWith('agent_')
      );
      
      const backend = allTools.filter((tool: MCPTool) => 
        !tool.name.startsWith('agent_')
      );
      
      // Fetch recorder tools
      const recorded = await this.getRecorderTools();
      
      // Fetch marketplace tools (from installed servers)
      const marketplace = await this.getMarketplaceTools();
      
      return {
        backend,
        agents,
        recorded,
        marketplace
      };
    } catch (error) {
      console.error('Failed to fetch tools:', error);
      return {
        backend: [],
        agents: [],
        recorded: [],
        marketplace: []
      };
    }
  }

  /**
   * Get tools generated by the recorder from agent-resources/tools directory
   */
  async getRecorderTools(): Promise<RecorderTool[]> {
    try {
      const response = await this.apiClient.get('/tools/recorder');
      return response.tools || [];
    } catch (error) {
      console.error('Failed to fetch recorder tools:', error);
      return [];
    }
  }

  /**
   * Get tools from installed marketplace servers
   */
  async getMarketplaceTools(): Promise<MCPTool[]> {
    try {
      const servers = await this.getInstalledServers();
      const tools: MCPTool[] = [];
      
      for (const server of servers) {
        if (server.status === 'running') {
          for (const toolName of server.tools) {
            if (!server.disabledTools.includes(toolName)) {
              tools.push({
                name: toolName,
                description: `Tool from ${server.name}`,
                source: 'marketplace',
                metadata: {
                  serverId: server.id,
                  serverName: server.name
                }
              });
            }
          }
        }
      }
      
      return tools;
    } catch (error) {
      console.error('Failed to fetch marketplace tools:', error);
      return [];
    }
  }

  /**
   * Execute a specific tool
   */
  async executeTool(
    toolName: string, 
    args: Record<string, any>
  ): Promise<ToolExecutionResult> {
    const startTime = Date.now();
    
    try {
      const response = await this.apiClient.post(`/tools/${toolName}/execute`, {
        arguments: args
      });
      
      const executionTime = Date.now() - startTime;
      
      // Record usage for billing
      await recordUsageAfterAction(this.apiClient.tenantId, 'apiCalls');
      
      return {
        success: response.success,
        result: response.result,
        error: response.error,
        output: response.message,
        executionTime
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        executionTime
      };
    }
  }

  /**
   * Get installed marketplace servers
   */
  async getInstalledServers(): Promise<MCPServer[]> {
    try {
      const response = await this.apiClient.get('/servers');
      const servers = response.servers || [];
      
      return servers.filter((server: MCPServer) => 
        server.status === 'running' || server.status === 'stopped'
      );
    } catch (error) {
      console.error('Failed to fetch installed servers:', error);
      return [];
    }
  }

  /**
   * Start an MCP server
   */
  async startServer(serverId: string): Promise<void> {
    try {
      const response = await this.apiClient.post(`/servers/${serverId}/start`);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to start server');
      }
    } catch (error) {
      console.error('Failed to start server:', error);
      throw error;
    }
  }

  /**
   * Stop an MCP server
   */
  async stopServer(serverId: string): Promise<void> {
    try {
      const response = await this.apiClient.post(`/servers/${serverId}/stop`);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to stop server');
      }
    } catch (error) {
      console.error('Failed to stop server:', error);
      throw error;
    }
  }

  /**
   * Toggle a tool on/off for a specific server
   */
  async toggleServerTool(
    serverId: string, 
    toolName: string, 
    enabled: boolean
  ): Promise<void> {
    try {
      const response = await this.apiClient.post(`/servers/${serverId}/toggle-tool`, {
        toolName,
        enabled
      });
      
      if (!response.success) {
        throw new Error(response.error || `Failed to ${enabled ? 'enable' : 'disable'} tool`);
      }
    } catch (error) {
      console.error('Failed to toggle tool:', error);
      throw error;
    }
  }

  /**
   * Download a recorder-generated tool
   */
  async downloadRecorderTool(toolPath: string): Promise<string> {
    try {
      const response = await this.apiClient.get(`/tools/recorder/download`, {
        params: { path: toolPath }
      });
      
      return response.code || '';
    } catch (error) {
      console.error('Failed to download tool:', error);
      throw error;
    }
  }

  /**
   * Install a tool from the marketplace
   */
  async installMarketplaceTool(toolId: string): Promise<void> {
    try {
      const response = await this.apiClient.post(`/marketplace/tools/${toolId}/install`);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to install tool');
      }
      
      // Record usage for billing
      await recordUsageAfterAction(this.apiClient.tenantId, 'toolsGenerated');
    } catch (error) {
      console.error('Failed to install marketplace tool:', error);
      throw error;
    }
  }

  /**
   * Install an MCP server from the marketplace
   */
  async installMarketplaceServer(serverId: string): Promise<void> {
    try {
      const response = await this.apiClient.post(`/marketplace/servers/${serverId}/install`);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to install server');
      }
      
      // Record usage for billing
      await recordUsageAfterAction(this.apiClient.tenantId, 'toolsGenerated');
    } catch (error) {
      console.error('Failed to install marketplace server:', error);
      throw error;
    }
  }

  /**
   * Search tools by name or description
   */
  async searchTools(query: string): Promise<{
    backendTools: MCPTool[];
    agentTools: MCPTool[];
    recorderTools: RecorderTool[];
  }> {
    const allTools = await this.getAllTools();
    const queryLower = query.toLowerCase();
    
    const filterTools = (tools: any[]) => tools.filter(tool => 
      tool.name.toLowerCase().includes(queryLower) ||
      (tool.description && tool.description.toLowerCase().includes(queryLower))
    );
    
    return {
      backendTools: filterTools(allTools.backendTools),
      agentTools: filterTools(allTools.agentTools),
      recorderTools: filterTools(allTools.recorderTools)
    };
  }

  /**
   * Get tool by name with detailed information
   */
  async getToolDetails(toolName: string): Promise<MCPTool | null> {
    try {
      const response = await this.apiClient.get(`/tools/${toolName}`);
      return response.tool || null;
    } catch (error) {
      console.error('Failed to get tool details:', error);
      return null;
    }
  }

  /**
   * Create a custom tool
   */
  async createCustomTool(
    name: string,
    description: string,
    code: string,
    inputSchema?: any
  ): Promise<void> {
    try {
      const response = await this.apiClient.post('/tools/custom', {
        name,
        description,
        code,
        inputSchema
      });
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to create custom tool');
      }
      
      // Record usage for billing
      await recordUsageAfterAction(this.apiClient.tenantId, 'toolsGenerated');
    } catch (error) {
      console.error('Failed to create custom tool:', error);
      throw error;
    }
  }

  /**
   * Delete a custom tool
   */
  async deleteCustomTool(toolName: string): Promise<void> {
    try {
      const response = await this.apiClient.delete(`/tools/custom/${toolName}`);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to delete custom tool');
      }
    } catch (error) {
      console.error('Failed to delete custom tool:', error);
      throw error;
    }
  }

  /**
   * Export tool configuration for sharing
   */
  async exportToolConfig(toolNames: string[]): Promise<any> {
    try {
      const response = await this.apiClient.post('/tools/export', {
        toolNames
      });
      
      return response.config || {};
    } catch (error) {
      console.error('Failed to export tool config:', error);
      throw error;
    }
  }

  /**
   * Import tool configuration
   */
  async importToolConfig(config: any): Promise<void> {
    try {
      const response = await this.apiClient.post('/tools/import', {
        config
      });
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to import tool config');
      }
    } catch (error) {
      console.error('Failed to import tool config:', error);
      throw error;
    }
  }

  /**
   * Get tool usage statistics
   */
  async getToolUsageStats(): Promise<{
    mostUsed: Array<{ name: string; count: number }>;
    recentlyUsed: Array<{ name: string; lastUsed: string }>;
    totalExectuions: number;
  }> {
    try {
      const response = await this.apiClient.get('/tools/stats');
      return response.stats || {
        mostUsed: [],
        recentlyUsed: [],
        totalExectuions: 0
      };
    } catch (error) {
      console.error('Failed to get tool usage stats:', error);
      return {
        mostUsed: [],
        recentlyUsed: [],
        totalExectuions: 0
      };
    }
  }

  /**
   * Validate tool configuration
   */
  async validateTool(toolName: string): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }> {
    try {
      const response = await this.apiClient.post(`/tools/${toolName}/validate`);
      return {
        valid: response.valid || false,
        errors: response.errors || [],
        warnings: response.warnings || []
      };
    } catch (error) {
      console.error('Failed to validate tool:', error);
      return {
        valid: false,
        errors: ['Failed to validate tool'],
        warnings: []
      };
    }
  }

  /**
   * Get MCP configuration for external tools
   */
  getMCPConfiguration(): MCPConfig {
    const serverUrl = this.getMCPServerUrl();
    
    return {
      serverUrl,
      ideConfigs: {
        windsurf: this.generateMCPConfig('Windsurf'),
        cursor: this.generateMCPConfig('Cursor'),
        cline: this.generateMCPConfig('Cline/Roo Code'),
        claudeCode: this.generateMCPConfig('Claude Code')
      }
    };
  }

  /**
   * Test MCP server connection
   */
  async testMCPConnection(): Promise<{
    connected: boolean;
    latency?: number;
    error?: string;
  }> {
    const startTime = Date.now();
    
    try {
      const response = await fetch(this.mcpServerUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      const latency = Date.now() - startTime;
      
      return {
        connected: response.ok,
        latency,
        error: response.ok ? undefined : `HTTP ${response.status}: ${response.statusText}`
      };
    } catch (error) {
      return {
        connected: false,
        error: error instanceof Error ? error.message : 'Unknown connection error'
      };
    }
  }
}

// Helper function to create tool service instance
export function createToolService(tenantId: string): ToolService {
  return new ToolService(tenantId);
}

// Export types for use in components
export type {
  MCPTool,
  MCPServer,
  RecorderTool,
  ToolExecutionResult,
  MCPConfig
};