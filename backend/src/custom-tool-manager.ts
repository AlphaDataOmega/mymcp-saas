/**
 * Custom Tool Manager
 * Creates focused, single-purpose tools that internally use marketplace MCP servers
 * Instead of exposing all marketplace tools, creates custom wrappers
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { serverManager } from './server-manager.js';
import { agentRegistry } from './agent-registry.js';

interface CustomTool {
  id: string;
  name: string;
  description: string;
  inputSchema: any;
  implementation: string; // Python code that calls marketplace servers
  marketplaceServers: string[]; // Required marketplace servers
  createdAt: Date;
  createdBy: 'archon' | 'user';
}

interface ToolCreationRequest {
  name: string;
  description: string;
  functionality: string; // What the tool should do
  requiredServers: string[]; // Which marketplace servers it needs
  inputParameters?: any; // Custom input schema
}

export class CustomToolManager {
  private tools: Map<string, CustomTool> = new Map();
  private toolsFilePath: string;

  constructor() {
    this.toolsFilePath = path.join(process.cwd(), 'data', 'custom_tools.json');
    this.ensureDataDirectory();
    this.loadTools();
  }

  private async ensureDataDirectory() {
    const dataDir = path.dirname(this.toolsFilePath);
    try {
      await fs.mkdir(dataDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create data directory:', error);
    }
  }

  private async loadTools() {
    try {
      const data = await fs.readFile(this.toolsFilePath, 'utf-8');
      const toolsData = JSON.parse(data);
      
      for (const tool of toolsData) {
        tool.createdAt = new Date(tool.createdAt);
        this.tools.set(tool.id, tool);
      }
      
      console.log(`🔧 Loaded ${this.tools.size} custom tools`);
    } catch (error) {
      console.log('🔧 No existing custom tools found, starting with empty registry');
    }
  }

  private async saveTools() {
    try {
      const toolsArray = Array.from(this.tools.values());
      await fs.writeFile(this.toolsFilePath, JSON.stringify(toolsArray, null, 2));
    } catch (error) {
      console.error('Failed to save custom tools:', error);
      throw error;
    }
  }

  async createCustomTool(request: ToolCreationRequest): Promise<string> {
    // Generate unique ID
    const id = `tool_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Check if tool with same name already exists
    for (const tool of this.tools.values()) {
      if (tool.name === request.name) {
        throw new Error(`Tool with name "${request.name}" already exists`);
      }
    }

    // Generate the tool implementation
    const implementation = this.generateToolImplementation(request);
    
    // Create input schema
    const inputSchema = request.inputParameters || this.generateDefaultInputSchema(request);

    const tool: CustomTool = {
      id,
      name: request.name,
      description: request.description,
      inputSchema,
      implementation,
      marketplaceServers: request.requiredServers,
      createdAt: new Date(),
      createdBy: 'archon'
    };

    this.tools.set(id, tool);
    await this.saveTools();

    console.log(`🔧 Created custom tool: ${tool.name} (ID: ${id})`);
    return id;
  }

  private generateToolImplementation(request: ToolCreationRequest): string {
    // Generate Python code that uses marketplace servers
    const serverCalls = request.requiredServers.map(server => {
      return this.getServerCallCode(server, request.functionality);
    }).join('\n\n');

    return `"""
Custom tool: ${request.name}
Generated by Archon for specific functionality
Uses marketplace servers: ${request.requiredServers.join(', ')}
"""

import requests
import json
import os
from typing import Dict, Any

def execute_${request.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    ${request.description}
    
    This tool internally uses marketplace MCP servers to provide focused functionality.
    """
    
    try:
        # Backend API configuration
        BACKEND_API_URL = "http://localhost:8100"
        
        ${serverCalls}
        
        return {
            "success": True,
            "result": "Tool executed successfully",
            "data": params  # Placeholder - replace with actual implementation
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

# Tool metadata
TOOL_METADATA = {
    "name": "${request.name}",
    "description": "${request.description}",
    "required_servers": ${JSON.stringify(request.requiredServers)},
    "custom_tool": True
}
`;
  }

  private getServerCallCode(serverName: string, functionality: string): string {
    // Generate server-specific code based on the server type
    switch (serverName.toLowerCase()) {
      case 'github':
        return `
        # GitHub server interaction
        github_response = requests.post(
            f"{BACKEND_API_URL}/tools/github_api_call/execute",
            json={"arguments": {"action": "list_repositories", "params": params}},
            timeout=30
        )
        if github_response.status_code == 200:
            github_data = github_response.json()
            # Process GitHub data for ${functionality}
        `;
      
      case 'slack':
        return `
        # Slack server interaction  
        slack_response = requests.post(
            f"{BACKEND_API_URL}/tools/slack_api_call/execute",
            json={"arguments": {"action": "send_message", "params": params}},
            timeout=30
        )
        if slack_response.status_code == 200:
            slack_data = slack_response.json()
            # Process Slack data for ${functionality}
        `;
      
      default:
        return `
        # Generic marketplace server interaction
        server_response = requests.post(
            f"{BACKEND_API_URL}/tools/${serverName}_api_call/execute",
            json={"arguments": params},
            timeout=30
        )
        if server_response.status_code == 200:
            server_data = server_response.json()
            # Process server data for ${functionality}
        `;
    }
  }

  private generateDefaultInputSchema(request: ToolCreationRequest): any {
    return {
      type: "object",
      properties: {
        input: {
          type: "string",
          description: `Input for ${request.name}`
        },
        options: {
          type: "object",
          description: "Additional options",
          additionalProperties: true
        }
      },
      required: ["input"],
      additionalProperties: false,
      $schema: "http://json-schema.org/draft-07/schema#"
    };
  }

  // Generate MCP tool that can be added to the main server
  generateMCPTool(toolId: string): any {
    const tool = this.tools.get(toolId);
    if (!tool) {
      throw new Error(`Custom tool with ID "${toolId}" not found`);
    }

    return {
      schema: {
        name: tool.name.toLowerCase().replace(/[^a-z0-9]/g, '_'),
        description: tool.description,
        inputSchema: tool.inputSchema
      },
      handle: async (context: any, params: any) => {
        try {
          // Execute the custom tool implementation
          const result = await this.executeTool(toolId, params);
          
          if (result.success) {
            return {
              content: [
                {
                  type: "text",
                  text: `Custom tool "${tool.name}" executed successfully:\n\n${JSON.stringify(result.data, null, 2)}`
                }
              ]
            };
          } else {
            return {
              content: [
                {
                  type: "text",
                  text: `Custom tool "${tool.name}" execution failed: ${result.error}`
                }
              ]
            };
          }
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: `Error executing custom tool: ${String(error)}`
              }
            ]
          };
        }
      },
      toolId,
      toolName: tool.name,
      isCustomTool: true
    };
  }

  private async executeTool(toolId: string, params: any): Promise<any> {
    const tool = this.tools.get(toolId);
    if (!tool) {
      return { success: false, error: `Tool ${toolId} not found` };
    }

    try {
      // Execute the Python implementation
      const { spawn } = await import('child_process');
      
      const pythonCode = `
${tool.implementation}

import json
import sys

# Get parameters from command line
if __name__ == "__main__":
    params = json.loads(sys.argv[1])
    result = execute_${tool.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}(params)
    print(json.dumps(result))
`;

      return new Promise((resolve) => {
        const pythonProcess = spawn('python3', ['-c', pythonCode, JSON.stringify(params)], {
          stdio: ['pipe', 'pipe', 'pipe']
        });

        let stdout = '';
        let stderr = '';

        pythonProcess.stdout.on('data', (data) => {
          stdout += data.toString();
        });

        pythonProcess.stderr.on('data', (data) => {
          stderr += data.toString();
        });

        pythonProcess.on('close', (code) => {
          if (code === 0 && stdout.trim()) {
            try {
              const result = JSON.parse(stdout.trim());
              resolve(result);
            } catch {
              resolve({ success: true, result: stdout.trim() });
            }
          } else {
            resolve({
              success: false,
              error: `Tool execution failed with code ${code}. stderr: ${stderr}`
            });
          }
        });
      });

    } catch (error) {
      return {
        success: false,
        error: `Failed to execute tool: ${String(error)}`
      };
    }
  }

  getTool(id: string): CustomTool | undefined {
    return this.tools.get(id);
  }

  getAllTools(): CustomTool[] {
    return Array.from(this.tools.values());
  }

  async deleteTool(id: string): Promise<boolean> {
    const deleted = this.tools.delete(id);
    if (deleted) {
      await this.saveTools();
      console.log(`🗑️ Deleted custom tool: ${id}`);
    }
    return deleted;
  }

  // Get tools that are ready to be used (their required servers are running)
  getReadyTools(): CustomTool[] {
    const runningServers = serverManager.getRunningServers();
    const runningServerNames = runningServers.map(s => s.name.toLowerCase());

    return this.getAllTools().filter(tool => {
      return tool.marketplaceServers.every(serverName => 
        runningServerNames.some(running => running.includes(serverName.toLowerCase()))
      );
    });
  }
}

// Singleton instance
export const customToolManager = new CustomToolManager();